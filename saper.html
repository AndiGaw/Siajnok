<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Przeprawa przez Arrakis ‚Äì Debug Mode</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: #000;
  color: #e6c47a;
  font-family: "Georgia", serif;
  overflow-x: hidden;
  user-select: none;
}

/* ===== T≈ÅO I EFEKTY ===== */
body.shake {
  animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
}
@keyframes shake {
  10%, 90% { transform: translate3d(-1px, 0, 0); }
  20%, 80% { transform: translate3d(2px, 0, 0); }
  30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
  40%, 60% { transform: translate3d(4px, 0, 0); }
}

.sand {
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    45deg,
    rgba(230,196,122,0.2),
    rgba(230,196,122,0.2) 2px,
    rgba(0,0,0,0) 6px
  );
  animation: drift 60s linear infinite;
  pointer-events: none;
  z-index: 1;
}

/* ===== UI G≈Å√ìWNE ===== */
.container {
  position: relative;
  z-index: 2;
  text-align: center;
  padding-top: 20px;
}

#controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  margin-bottom: 10px;
}
#controls button {
  font-size: 1.2em;
  padding: 10px 20px;
  width: 320px;
  background: #111;
  color: #e6c47a;
  border: 2px solid #e6c47a;
  border-radius: 8px;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(230,196,122,0.5);
}
#controls button:hover {
  background: #222;
  box-shadow: 0 0 20px rgba(230,196,122,0.8);
}

#stats {
  margin-top: 10px;
  font-size: 0.9em;
  min-height: 1.2em;
}

/* ===== GAME AREA ===== */
#game-area {
  display: flex;
  align-items: flex-start;
  gap: 20px;
  margin: 20px auto;
  width: max-content;
}

#helipadA, #helipadB {
  width: 120px;
  height: 120px;
  background: #111;
  border: 2px solid #e6c47a;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  flex-shrink: 0;
}
#helipadB { visibility: hidden; }

/* ===== PLANSZA G≈Å√ìWNA ===== */
#board-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: calc(50px * 10 + 3px * 9);
}

#board {
  display: inline-grid;
  gap: 3px;
}

.cell {
  width: 50px;
  height: 50px;
  background: #222;
  border: 2px solid #e6c47a;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-weight: bold;
  font-size: 1.2em;
}

.visited { background: #444; }
.start   { background: darkgreen; }
.goal    { background: darkblue; }
.worm    { background: darkred; color: white; }

/* ===== MAPA DEBUGOWANIA (Przywr√≥cona) ===== */
#worm-map {
  margin-top: 15px;
  display: inline-grid;
  gap: 2px;
  border: 1px solid #e6c47a;
  padding: 2px;
  background: #000;
}

#worm-map .cell {
  width: 20px;
  height: 20px;
  font-size: 0.8em;
  border: 1px solid #555;
  cursor: default;
}
</style>
</head>

<body>
<div class="sand"></div>

<div class="container">
  <h1>Przeprawa przez Arrakis</h1>
  <p>Przejd≈∫ z punktu <b>A</b> do <b>B</b> unikajƒÖc Czerwii Pustyni!</p>

  <div id="controls">
    <button onclick="playNarrator()">üéôÔ∏è Narrator (T≈Ço)</button>
    <button onclick="showGame(); startGame()">üèúÔ∏è Wyrusz w drogƒô</button>
    <label><input type="checkbox" id="hardMode"> Hard Mode ‚Äì ruchome czerwie</label>
  </div>

  <div id="sonarOutput" style="font-weight: bold; color: #ff5555; text-shadow: 0 0 10px #ff0000; height: 20px;">
    Kliknij start, by uruchomiƒá systemy...
  </div>
  <div id="stats">Kroki: 0 | Punktacja: 0</div>

  <div id="game-area" style="display:none">
    <div id="helipadA">LƒÖdowisko A</div>

    <div id="board-wrapper">
      <div id="board"></div>
      <div id="worm-map"></div>
    </div>

    <div id="helipadB">LƒÖdowisko B</div>
  </div>
</div>

<script>
// --- ZMIENNE GLOBALNE ---
const size = 10;
const wormsCount = 12;
let board = []; // G≈Ç√≥wna tablica stanu gry i referencji DOM planszy
let debugCells = []; // Tablica referencji DOM dla mapy debugowania
let playerPos = {x:0, y:0};
let steps = 0;
let gameOver = false;
let audioCtx = null;

// --- INICJALIZACJA ---
function showGame() {
  document.getElementById("game-area").style.display = "flex";
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function startGame() {
  const boardDiv = document.getElementById("board");
  const wormMapDiv = document.getElementById("worm-map");
  
  // Reset
  board = [];
  debugCells = [];
  gameOver = false;
  playerPos = {x:0, y:0};
  steps = 0;
  
  // UI Reset
  document.getElementById("helipadB").style.visibility = "hidden";
  document.getElementById("stats").innerText = "Kroki: 0 | Punktacja: 0";
  document.getElementById("sonarOutput").innerText = "Systemy aktywne.";
  document.body.className = "";

  boardDiv.innerHTML = "";
  boardDiv.style.gridTemplateColumns = `repeat(${size},50px)`;
  wormMapDiv.innerHTML = "";
  wormMapDiv.style.gridTemplateColumns = `repeat(${size},20px)`;

  // Generowanie planszy g≈Ç√≥wnej ORAZ mapy debugowania
  for (let y = 0; y < size; y++) {
    board[y] = [];
    for (let x = 0; x < size; x++) {
      // 1. G≈Ç√≥wna kom√≥rka
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.onclick = () => moveTo(x, y);
      boardDiv.appendChild(cell);

      board[y][x] = { 
        worm: false, 
        visited: false, 
        el: cell 
      };

      // 2. Kom√≥rka debugowania
      const dbgCell = document.createElement("div");
      dbgCell.className = "cell";
      wormMapDiv.appendChild(dbgCell);
      debugCells.push(dbgCell); // Zapisujemy w p≈Çaskiej tablicy dla szybkiego dostƒôpu
    }
  }

  placeWorms();
  drawBoard();
  drawDebugMap(); // Rysuj mapƒô debugowania na starcie
}

function placeWorms() {
  let placed = 0;
  while (placed < wormsCount) {
    let x = Math.floor(Math.random() * size);
    let y = Math.floor(Math.random() * size);
    if ((x === 0 && y === 0) || (x === size-1 && y === size-1)) continue;
    
    if (!board[y][x].worm) {
      board[y][x].worm = true;
      placed++;
    }
  }
}

// --- LOGIKA RUCHU I GRY ---
function isAdjacent(x, y) {
  return Math.abs(playerPos.x - x) + Math.abs(playerPos.y - y) === 1;
}

function moveTo(x, y) {
  if (gameOver || !isAdjacent(x, y)) return;
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

  playerPos = {x, y};
  steps++;
  board[y][x].visited = true;

  if (board[y][x].worm) {
    killPlayer("Wszed≈Çe≈õ prosto w paszczƒô Czerwia!");
    drawDebugMap(); // Aktualizuj debug mapƒô przy ≈õmierci
    return;
  }

  if (document.getElementById("hardMode").checked) {
    moveWormsLogic();
    if (board[playerPos.y][playerPos.x].worm) {
      killPlayer("Czerw Pustyni wynurzy≈Ç siƒô pod TobƒÖ!");
      drawDebugMap(); // Aktualizuj debug mapƒô przy ≈õmierci
      return;
    }
  }

  if (x === size - 1 && y === size - 1) {
    winGame();
    drawDebugMap();
    return;
  }

  drawBoard();
  drawDebugMap(); // Aktualizuj mapƒô debugowania po ka≈ºdym ruchu
  updateSonarAndStats();
}

// Logika Hard Mode (bez zmian - czerwie nie nachodzƒÖ na siebie)
function moveWormsLogic() {
  let worms = [];
  for(let y=0; y<size; y++) {
    for(let x=0; x<size; x++) {
      if(board[y][x].worm) {
        worms.push({x, y});
        board[y][x].worm = false;
      }
    }
  }
  worms.sort(() => Math.random() - 0.5);

  worms.forEach(w => {
    const dirs = [[0,0], [0,1], [0,-1], [1,0], [-1,0]];
    let moved = false;
    for(let i=0; i<5; i++) {
        const d = dirs[Math.floor(Math.random() * dirs.length)];
        const nx = w.x + d[0];
        const ny = w.y + d[1];
        if (nx >= 0 && nx < size && ny >= 0 && ny < size && 
            !(nx === 0 && ny === 0) && !(nx === size-1 && ny === size-1)) {
            if(!board[ny][nx].worm) {
                board[ny][nx].worm = true;
                moved = true;
                break;
            }
        }
    }
    if(!moved) board[w.y][w.x].worm = true;
  });
}

// --- RENDEROWANIE (G≈Ç√≥wna plansza - zoptymalizowana) ---
function drawBoard() {
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const cellData = board[y][x];
      const el = cellData.el;
      el.textContent = "";
      el.className = "cell";
      if (cellData.visited) el.classList.add("visited");
      if (x === 0 && y === 0) { el.classList.add("start"); el.textContent = "A"; }
      if (x === size - 1 && y === size - 1) { el.classList.add("goal"); el.textContent = "B"; }

      if (x === playerPos.x && y === playerPos.y) {
        el.textContent = "üë£";
        el.style.color = "#fff";
      } else {
        el.style.color = "";
      }
    }
  }
}

// --- RENDEROWANIE (Mapa Debugowania - NOWE) ---
function drawDebugMap() {
    for(let y=0; y<size; y++) {
        for(let x=0; x<size; x++) {
            // Wyliczamy indeks w p≈Çaskiej tablicy debugCells
            const index = y * size + x;
            const el = debugCells[index];
            const gameData = board[y][x];

            el.className = "cell";
            el.textContent = "";

            if(gameData.worm) {
                el.classList.add("worm");
                el.textContent = "ü™±";
            }
            
            // Opcjonalnie: poka≈º te≈º gracza na minimapie dla u≈Çatwienia test√≥w
            if(x === playerPos.x && y === playerPos.y) {
                 el.textContent = "üë£";
                 el.style.color = "white";
            } else {
                 el.style.color = "";
            }
        }
    }
}

function revealWormsOnMainBoard() {
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      if (board[y][x].worm) {
        const el = board[y][x].el;
        el.classList.add("worm");
        el.textContent = "ü™±";
      }
    }
  }
}

// --- SONAR I AUDIO (bez zmian) ---
function updateSonarAndStats() {
  let minDistance = 999;
  for(let y=0; y<size; y++) {
    for(let x=0; x<size; x++) {
      if(board[y][x].worm) {
        const dist = Math.abs(playerPos.x - x) + Math.abs(playerPos.y - y);
        if(dist < minDistance) minDistance = dist;
      }
    }
  }

  const sonarDiv = document.getElementById("sonarOutput");
  let score = Math.max(0, 100 - steps * 2);
  document.getElementById("stats").innerText = `Kroki: ${steps} | Punktacja: ${score}`;

  if (minDistance <= 1) {
    sonarDiv.innerText = "‚ÄºÔ∏è WYKRYTO RUCH PIONOWY! (Dystans: 1)";
    sonarDiv.style.opacity = 1;
    playSonarSound(800, "sawtooth", 0.3);
    if("vibrate" in navigator) navigator.vibrate(200); 
  } 
  else if (minDistance === 2) {
    sonarDiv.innerText = "‚ö†Ô∏è Silne wstrzƒÖsy... (Dystans: 2)";
    sonarDiv.style.opacity = 0.8;
    playSonarSound(400, "square", 0.2);
    if("vibrate" in navigator) navigator.vibrate(50);
  } 
  else if (minDistance === 3) {
    sonarDiv.innerText = "üîä S≈Çyszysz szum piasku (Dystans: 3)";
    sonarDiv.style.opacity = 0.5;
    playSonarSound(150, "sine", 0.1);
  } 
  else {
    sonarDiv.innerText = "Stan stabilny.";
    sonarDiv.style.opacity = 0.3;
  }
}

function playSonarSound(freq, type, vol) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(freq * 0.5, audioCtx.currentTime + 0.3);
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.3);
}

// --- KONIEC GRY ---
function killPlayer(msg) {
  gameOver = true;
  revealWormsOnMainBoard();
  document.body.classList.add("shake");
  document.getElementById("sonarOutput").innerText = "üíÄ " + msg;
  playSonarSound(100, "sawtooth", 0.8);
}

function winGame() {
  gameOver = true
