<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Przeprawa przez Arrakis v2.0</title>

<style>
/* ===== STYLE BAZOWE ===== */
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: #050505;
  color: #e6c47a;
  font-family: "Segoe UI", "Georgia", serif;
  overflow: hidden; /* Brak paska przewijania */
  user-select: none;
}

/* Animacja trzƒôsienia (u≈ºywana przy ≈õmierci/ruchu) */
@keyframes shake {
  0% { transform: translate(1px, 1px) rotate(0deg); }
  10% { transform: translate(-1px, -2px) rotate(-1deg); }
  20% { transform: translate(-3px, 0px) rotate(1deg); }
  30% { transform: translate(3px, 2px) rotate(0deg); }
  40% { transform: translate(1px, -1px) rotate(1deg); }
  50% { transform: translate(-1px, 2px) rotate(-1deg); }
  60% { transform: translate(-3px, 1px) rotate(0deg); }
  70% { transform: translate(3px, 1px) rotate(-1deg); }
  80% { transform: translate(-1px, -1px) rotate(1deg); }
  90% { transform: translate(1px, 2px) rotate(0deg); }
  100% { transform: translate(1px, -2px) rotate(-1deg); }
}

.shake-effect {
  animation: shake 0.5s;
}

/* T≈Ço piasku */
.sand-bg {
  position: fixed;
  inset: 0;
  background: 
    radial-gradient(circle at 50% 50%, rgba(230, 196, 122, 0.1), transparent 80%),
    repeating-linear-gradient(45deg, rgba(200, 150, 50, 0.05) 0px, rgba(0,0,0,0) 2px);
  z-index: -1;
  pointer-events: none;
}

/* ===== UI ===== */
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 15px;
}

h1 { margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px #e6c47a; }

.controls {
  display: flex;
  gap: 15px;
  background: rgba(20, 20, 20, 0.9);
  padding: 15px;
  border: 1px solid #444;
  border-radius: 8px;
}

button {
  background: #222;
  color: #e6c47a;
  border: 1px solid #e6c47a;
  padding: 8px 16px;
  cursor: pointer;
  font-weight: bold;
  transition: 0.2s;
}
button:hover { background: #e6c47a; color: #000; }

.status-bar {
  display: flex;
  gap: 20px;
  font-size: 1.1em;
  min-height: 1.5em;
}

.sonar-text {
  color: #ff4444;
  font-weight: bold;
  text-shadow: 0 0 5px red;
  opacity: 0;
  transition: opacity 0.3s;
}

/* ===== PLANSZA ===== */
#game-wrapper {
  display: flex;
  align-items: center;
  gap: 20px;
  opacity: 0.3; /* Przygaszone przed startem */
  transition: opacity 0.5s;
}

.helipad {
  width: 60px;
  height: 60px;
  border: 2px dashed #e6c47a;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  color: #666;
}
.helipad.active { color: #e6c47a; border-style: solid; box-shadow: 0 0 15px #e6c47a; }

#board {
  display: grid;
  grid-template-columns: repeat(10, 50px);
  gap: 4px;
  background: rgba(0,0,0,0.5);
  padding: 5px;
  border: 1px solid #333;
}

.cell {
  width: 50px;
  height: 50px;
  background: #1a1a1a;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5em;
  cursor: pointer;
  transition: background 0.2s;
  border-radius: 4px;
}

.cell:hover { background: #2a2a2a; }
.cell.visited { background: #332a1a; border: 1px solid #554422; }
.cell.player { background: #e6c47a; color: #000; box-shadow: 0 0 10px #e6c47a; }
.cell.worm { background: #800; color: #fff; }
.cell.start { border: 2px solid green; }
.cell.goal { border: 2px solid blue; }

/* ===== OVERLAY ===== */
#overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.85);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  visibility: hidden;
  opacity: 0;
  transition: 0.3s;
}
#overlay.show { visibility: visible; opacity: 1; }
#overlay h2 { font-size: 3em; margin-bottom: 20px; }
</style>
</head>
<body>

<div class="sand-bg"></div>

<div class="container">
  <h1>Przeprawa przez Arrakis</h1>
  
  <div class="controls">
    <button onclick="initGame()">üîÑ Nowa Gra</button>
    <label style="display:flex; align-items:center; gap:5px; cursor:pointer;">
      <input type="checkbox" id="hardMode"> Hard Mode (Ruchome czerwie)
    </label>
    <label style="display:flex; align-items:center; gap:5px; cursor:pointer;">
      <input type="checkbox" id="cheatMode" onchange="toggleCheat()"> üó∫Ô∏è Mapa (Cheat)
    </label>
  </div>

  <div class="status-bar">
    <span>Kroki: <b id="stepCount">0</b></span>
    <span id="sonarMsg" class="sonar-text">‚ö†Ô∏è WYKRYTO DRGANIA ‚ö†Ô∏è</span>
  </div>

  <div id="game-wrapper">
    <div class="helipad active">A</div>
    <div id="board"></div>
    <div class="helipad" id="goalPad">B</div>
  </div>
</div>

<div id="overlay">
  <h2 id="endTitle">Koniec Gry</h2>
  <p id="endDesc">Opis</p>
  <button onclick="document.getElementById('overlay').classList.remove('show'); initGame()" style="font-size:1.5em; margin-top:20px;">Zagraj ponownie</button>
</div>

<script>
// --- KONFIGURACJA ---
const SIZE = 10;
const WORM_COUNT = 12;

// --- STAN GRY ---
let boardState = []; // Tablica 2D przechowujƒÖca obiekty { worm, visited, element }
let player = { x: 0, y: 0 };
let steps = 0;
let isGameOver = false;

// --- INICJALIZACJA ---
function initGame() {
  const boardEl = document.getElementById("board");
  boardEl.innerHTML = "";
  boardState = [];
  
  // Reset UI
  document.getElementById("game-wrapper").style.opacity = "1";
  document.getElementById("overlay").classList.remove("show");
  document.getElementById("goalPad").classList.remove("active");
  document.getElementById("stepCount").innerText = "0";
  updateSonar(false);
  
  steps = 0;
  isGameOver = false;
  player = { x: 0, y: 0 };

  // Generowanie planszy i cache'owanie element√≥w DOM
  for (let y = 0; y < SIZE; y++) {
    const row = [];
    for (let x = 0; x < SIZE; x++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      if (x === 0 && y === 0) cell.classList.add("start");
      if (x === SIZE - 1 && y === SIZE - 1) cell.classList.add("goal");
      
      // Event Listener (zamiast inline onclick)
      cell.addEventListener("click", () => handleMove(x, y));

      boardEl.appendChild(cell);
      
      // Zapisujemy stan logiczny I referencjƒô do DOM w jednym obiekcie
      row.push({
        x, y,
        worm: false,
        visited: false,
        element: cell // <-- TO JEST KLUCZ DO WYDAJNO≈öCI
      });
    }
    boardState.push(row);
  }

  placeWorms();
  render();
}

// --- LOGIKA CZERWI ---
function placeWorms() {
  let placed = 0;
  while (placed < WORM_COUNT) {
    const rx = Math.floor(Math.random() * SIZE);
    const ry = Math.floor(Math.random() * SIZE);
    // Nie stawiaj na starcie ani na mecie
    if ((rx === 0 && ry === 0) || (rx === SIZE-1 && ry === SIZE-1)) continue;
    
    if (!boardState[ry][rx].worm) {
      boardState[ry][rx].worm = true;
      placed++;
    }
  }
}

function moveWorms() {
  // Kopia lokalizacji czerwi
  const currentWorms = [];
  for(let y=0; y<SIZE; y++) {
    for(let x=0; x<SIZE; x++) {
      if(boardState[y][x].worm) {
        currentWorms.push({x, y});
        boardState[y][x].worm = false; // Usuwamy stare
      }
    }
  }

  // Przesuwamy ka≈ºdego
  currentWorms.forEach(w => {
    const dirs = [[0,0], [0,1], [0,-1], [1,0], [-1,0]];
    // Pr√≥buj znale≈∫ƒá wolne miejsce (3 pr√≥by losowe)
    let moved = false;
    for(let i=0; i<3; i++) {
        const d = dirs[Math.floor(Math.random() * dirs.length)];
        const nx = w.x + d[0];
        const ny = w.y + d[1];

        if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && 
            !(nx === 0 && ny === 0) && !(nx === SIZE-1 && ny === SIZE-1)) { // Nie wchod≈∫ na start/meta
            
            // Unikaj nadpisywania innego czerwia w tym samym ruchu (prosta heurystyka)
            if(!boardState[ny][nx].worm) {
                boardState[ny][nx].worm = true;
                moved = true;
                break;
            }
        }
    }
    // Je≈õli nie uda≈Ço siƒô ruszyƒá (np. t≈Çok), zosta≈Ñ w miejscu (lub nadpisz je≈õli musisz)
    if(!moved) boardState[w.y][w.x].worm = true;
  });
}

// --- RUCH GRACZA ---
function handleMove(x, y) {
  if (isGameOver) return;
  
  // Sprawdzenie sƒÖsiedztwa (Manhattan distance = 1)
  const dist = Math.abs(player.x - x) + Math.abs(player.y - y);
  if (dist !== 1) return;

  // Logika ruchu
  player = { x, y };
  steps++;
  boardState[y][x].visited = true;
  document.getElementById("stepCount").innerText = steps;

  // 1. Sprawd≈∫ ≈õmierƒá
  if (boardState[y][x].worm) {
    endGame(false);
    return;
  }

  // 2. Hard Mode
  if (document.getElementById("hardMode").checked) {
    moveWorms();
    // Po ruchu czerwi, sprawd≈∫ czy czer wlaz≈Ç na gracza
    if (boardState[player.y][player.x].worm) {
        endGame(false);
        return;
    }
  }

  // 3. Sprawd≈∫ wygranƒÖ
  if (x === SIZE - 1 && y === SIZE - 1) {
    endGame(true);
    return;
  }

  render();
  checkSonar();
}

// --- RENDEROWANIE ---
function render() {
  const cheat = document.getElementById("cheatMode").checked;

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const cellData = boardState[y][x];
      const el = cellData.element;

      // Reset klas
      el.className = "cell"; 
      el.textContent = "";

      if (x === 0 && y === 0) { el.classList.add("start"); el.textContent = "A"; }
      else if (x === SIZE-1 && y === SIZE-1) { el.classList.add("goal"); el.textContent = "B"; }

      if (cellData.visited) el.classList.add("visited");

      // Gracz
      if (x === player.x && y === player.y) {
        el.classList.add("player");
        el.textContent = "üë£";
      }

      // Cheat mode / Debug
      if (cellData.worm && cheat) {
        el.textContent = "ü™±";
        el.style.opacity = "0.5";
      }
    }
  }
}

// --- DODATKI (Sonar & EndGame) ---
function checkSonar() {
  let minDistance = Infinity;
  
  // Szukamy najbli≈ºszego czerwia
  for(let y=0; y<SIZE; y++) {
    for(let x=0; x<SIZE; x++) {
      if(boardState[y][x].worm) {
        const dist = Math.abs(player.x - x) + Math.abs(player.y - y);
        if(dist < minDistance) minDistance = dist;
      }
    }
  }

  // Je≈õli czer jest w odleg≈Ço≈õci 1 lub 2 p√≥l
  updateSonar(minDistance <= 2);
}

function updateSonar(isDanger) {
  const el = document.getElementById("sonarMsg");
  el.style.opacity = isDanger ? "1" : "0";
  if(isDanger && "vibrate" in navigator) navigator.vibrate(50); // Wibracja na telefonie
}

function toggleCheat() {
  render();
}

function endGame(win) {
  isGameOver = true;
  
  // Ods≈Ço≈Ñ wszystkie czerwie
  for(let y=0; y<SIZE; y++) {
    for(let x=0; x<SIZE; x++) {
      if(boardState[y][x].worm) {
        const el = boardState[y][x].element;
        el.classList.add("worm");
        el.textContent = "ü™±";
      }
    }
  }

  // Overlay
  const overlay = document.getElementById("overlay");
  const title = document.getElementById("endTitle");
  const desc = document.getElementById("endDesc");

  if (win) {
    title.innerText = "ZWYCIƒòSTWO!";
    title.style.color = "#e6c47a";
    desc.innerText = `Dotar≈Çe≈õ do lƒÖdowiska B w ${steps} krokach.`;
    document.getElementById("goalPad").classList.add("active");
  } else {
    document.body.classList.add("shake-effect");
    setTimeout(() => document.body.classList.remove("shake-effect"), 500);
    
    title.innerText = "PO≈ªARTY...";
    title.style.color = "#800";
    desc.innerText = "Shai-Hulud upomnia≈Ç siƒô o Ciebie.";
  }
  
  setTimeout(() => overlay.classList.add("show"), 800);
}

// Start
initGame();

</script>
</body>
</html>
