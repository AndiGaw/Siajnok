<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Przeprawa przez Arrakis ‚Äì Stabilna Wersja</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: #000;
  color: #e6c47a;
  font-family: "Georgia", serif;
  overflow-x: hidden;
  user-select: none;
}

/* ===== UI & LAYOUT ===== */
.container {
  position: relative;
  z-index: 20;
  text-align: center;
  padding-top: 20px;
  /* Zapobiega skakaniu szeroko≈õci */
  min-width: 800px; 
}

#controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
  height: 120px; /* Rezerwuje miejsce na przyciski */
}
#controls button {
  font-size: 1.2em;
  padding: 10px 20px;
  width: 320px;
  background: #111;
  color: #e6c47a;
  border: 2px solid #e6c47a;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
}
#controls button:hover {
  background: #222;
  box-shadow: 0 0 15px rgba(230,196,122,0.6);
}
#controls button.active {
  background: #4a3b1a;
  border-color: #fff;
}

#stats {
  font-size: 1em;
  font-weight: bold;
  margin-bottom: 10px;
  height: 20px; /* Rezerwuje miejsce na tekst */
}

/* ===== OBSZAR GRY (Layout Sztywny) ===== */
#game-area {
  display: flex;
  justify-content: center; /* Wy≈õrodkowanie */
  align-items: flex-start;
  gap: 20px;
  margin: 0 auto;
  width: max-content; /* Dopasuj do zawarto≈õci */
}

#helipadA, #helipadB {
  width: 120px;
  height: 120px;
  background: #111;
  border: 2px solid #e6c47a;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  flex-shrink: 0;
  box-shadow: 0 0 10px rgba(0,0,0,0.5);
}
#helipadB { 
  opacity: 0.3; 
  transition: opacity 1s;
}
#helipadB.visible { opacity: 1; box-shadow: 0 0 20px #00f; }

#board-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Sztywne wymiary planszy, ≈ºeby nie skaka≈Ça */
#board {
  display: grid;
  grid-template-columns: repeat(10, 50px);
  gap: 3px;
  padding: 5px;
  background: #000;
  border: 1px solid #333;
}
#worm-map {
  margin-top: 15px;
  display: grid;
  grid-template-columns: repeat(10, 20px);
  gap: 2px;
}

/* ===== KOM√ìRKI ===== */
.cell {
  width: 50px;
  height: 50px;
  background: #1a1a1a;
  border: 2px solid #333; 
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer; 
  font-weight: bold;
  font-size: 1.4em;
  transition: background 0.2s, border-color 0.2s;
}
/* Kiedy gra nie jest aktywna */
.cell.inactive {
  cursor: default;
  opacity: 0.5;
}

/* Klasy stanu */
.visited { background: #554a33 !important; border-color: #776a4a; }
.start   { background: darkgreen !important; color: #fff; }
.goal    { background: darkblue !important; color: #fff; }
.worm    { background: darkred !important; color: white; }

.player {
  color: #ff3333 !important;
  text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
  font-size: 1.6em;
}

#worm-map .cell {
  width: 20px;
  height: 20px;
  font-size: 0.9em;
  border: 1px solid #333;
}

/* ===== EFEKTY POGODOWE ===== */
.sand {
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    45deg,
    rgba(230,196,122,0.1),
    rgba(230,196,122,0.1) 2px,
    rgba(0,0,0,0) 6px
  );
  animation: drift 60s linear infinite;
  pointer-events: none;
  z-index: 10;
}
@keyframes drift { from { background-position: 0 0; } to { background-position: 1000px 0; } }

/* Dr≈ºenie */
@keyframes shake-violent {
  0%, 100% { transform: translate(0,0); }
  25% { transform: translate(-3px, 3px); }
  75% { transform: translate(3px, -3px); }
}
.shake-dist-0 { animation: shake-violent 0.2s infinite; }

</style>
</head>

<body>
<div class="sand"></div>

<div class="container">
  <h1>Przeprawa przez Arrakis</h1>
  <p>Czerwone stopy to Twoja pozycja.</p>

  <div id="controls">
    <button id="narratorBtn" onclick="toggleNarrator()">üéôÔ∏è Narrator (Start)</button>
    <button onclick="startGame()">‚ò¢Ô∏è RESTART SYSTEM√ìW</button>
    <label style="margin-top: 5px;"><input type="checkbox" id="hardMode"> Hard Mode ‚Äì ruchome czerwie</label>
  </div>

  <div id="stats">Oczekiwanie na start...</div>

  <div id="game-area">
    <div id="helipadA">LƒÖdowisko A</div>

    <div id="board-wrapper">
      <div id="board"></div>
      <div id="worm-map"></div>
    </div>

    <div id="helipadB">LƒÖdowisko B</div>
  </div>
</div>

<script>
// --- KONFIGURACJA ---
const size = 10;
const wormsCount = 12;

// --- ZMIENNE STANU ---
let board = [];
let playerPos = {x:0, y:0};
let steps = 0;
let score = 0;
let gameOver = true; // Gra zaczyna siƒô jako nieaktywna
let gameStarted = false;

// --- AUDIO (Bez zmian logicznych, tylko inicjalizacja) ---
let narratorAudio = null;
let audioCtx = null;
let noiseSource = null; 
let noiseFilter = null; 
let noiseGain = null;   

function toggleNarrator() {
  const btn = document.getElementById("narratorBtn");
  if (!narratorAudio) {
    narratorAudio = new Audio("Saper_Diuny.mp3");
    narratorAudio.addEventListener('ended', () => {
       narratorAudio.currentTime = 0;
       btn.innerText = "üéôÔ∏è Narrator (Start)";
       btn.classList.remove("active");
    });
  }
  if (narratorAudio.paused) {
    narratorAudio.play().then(() => {
      btn.innerText = "‚è∏Ô∏è Narrator (Pauza)";
      btn.classList.add("active");
    }).catch(err => {
      console.log("Audio err", err);
      alert("Brak pliku Saper_Diuny.mp3. Gra dzia≈Ça bez niego.");
    });
  } else {
    narratorAudio.pause();
    btn.innerText = "‚ñ∂Ô∏è Narrator (Wzn√≥w)";
    btn.classList.remove("active");
  }
}

function initAudioContext() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function startBackgroundDrone() {
  initAudioContext();
  if (noiseSource) { try { noiseSource.stop(); } catch(e){} noiseSource = null; }

  const bufferSize = audioCtx.sampleRate * 2; 
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

  noiseSource = audioCtx.createBufferSource();
  noiseSource.buffer = buffer;
  noiseSource.loop = true;

  noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = 'lowpass';
  noiseFilter.frequency.value = 150; 
  noiseGain = audioCtx.createGain();
  noiseGain.gain.value = 0.05;

  noiseSource.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);
  noiseSource.start();
}

function stopBackgroundDrone() {
  if (noiseSource) {
    const now = audioCtx.currentTime;
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5); 
    noiseSource.stop(now + 1.5);
    noiseSource = null;
  }
}

function updateDroneSound(distance) {
  if (!noiseFilter || !audioCtx) return;
  const now = audioCtx.currentTime;
  let targetFreq, targetVol;
  if (distance === 0) { targetFreq = 3000; targetVol = 0; } 
  else if (distance === 1) { targetFreq = 1200; targetVol = 0.50; } 
  else if (distance === 2) { targetFreq = 600; targetVol = 0.25; } 
  else if (distance === 3) { targetFreq = 300; targetVol = 0.15; } 
  else { targetFreq = 120; targetVol = 0.08; }
  noiseFilter.frequency.exponentialRampToValueAtTime(targetFreq, now + 0.5);
  noiseGain.gain.linearRampToValueAtTime(targetVol, now + 0.5);
}

// --- LOGIKA GRY ---

// Funkcja wywo≈Çywana OD RAZU przy za≈Çadowaniu strony
window.onload = function() {
  createGridStructure(); // Tworzy planszƒô wizualnie (pustƒÖ)
};

function createGridStructure() {
  const boardDiv = document.getElementById("board");
  const wormDiv  = document.getElementById("worm-map");
  boardDiv.innerHTML = "";
  wormDiv.innerHTML = "";

  // Generujemy siatkƒô, ale "pustƒÖ" logicznie
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      // G≈Ç√≥wna plansza
      const cell = document.createElement("div");
      cell.className = "cell inactive"; // Domy≈õlnie nieaktywna
      cell.dataset.x = x;
      cell.dataset.y = y;
      cell.onclick = () => moveTo(x,y); 
      // Oznaczenie startu i mety wizualnie
      if(x===0 && y===0) { cell.classList.add("start"); cell.textContent="A"; }
      if(x===size-1 && y===size-1) { cell.classList.add("goal"); cell.textContent="B"; }
      boardDiv.appendChild(cell);

      // Minimapa
      const wcell = document.createElement("div");
      wcell.className = "cell";
      wcell.dataset.x = x;
      wcell.dataset.y = y;
      wormDiv.appendChild(wcell);
    }
  }
}

function startGame() {
  initAudioContext();
  startBackgroundDrone(); 
  
  // Reset zmiennych
  board = [];
  gameOver = false;
  gameStarted = true;
  playerPos = {x:0, y:0};
  steps = 0;
  score = 100;

  document.getElementById("stats").innerText = "Kroki: 0 | Punktacja: 100";
  document.body.className = "";
  document.getElementById("helipadB").classList.remove("visible");

  // Inicjalizacja tablicy logicznej
  for (let y = 0; y < size; y++) {
    board[y] = [];
    for (let x = 0; x < size; x++) {
      board[y][x] = { worm:false, visited:false };
    }
  }
  board[0][0].visited = true;

  // Aktywacja kom√≥rek wizualnie
  const cells = document.querySelectorAll("#board .cell");
  cells.forEach(c => c.classList.remove("inactive", "visited", "player", "worm"));

  placeWorms();
  drawBoard();
  updateWormMap();
  checkProximity(0,0);
}

function placeWorms() {
  let placed = 0;
  while (placed < wormsCount) {
    let x = Math.floor(Math.random() * size);
    let y = Math.floor(Math.random() * size);
    if ((x < 2 && y < 2) || (x > size-3 && y > size-3)) continue;
    if (!board[y][x].worm) {
      board[y][x].worm = true;
      placed++;
    }
  }
}

function isAdjacent(x,y) {
  return Math.abs(playerPos.x-x) + Math.abs(playerPos.y-y) === 1;
}

function moveTo(x,y) {
  if(!gameStarted) {
    alert("Kliknij 'RESTART SYSTEM√ìW', aby rozpoczƒÖƒá.");
    return;
  }
  if(gameOver) return;
  if(!isAdjacent(x,y)) return;

  initAudioContext();

  playerPos = {x,y};
  steps++;
  board[y][x].visited = true;
  score = Math.max(0, 100 - steps);
  document.getElementById("stats").innerText = `Kroki: ${steps} | Punktacja: ${score}`;

  if (board[y][x].worm) {
    handleDeath();
    return;
  }

  moveWorms();

  if (board[playerPos.y][playerPos.x].worm) {
    handleDeath();
    return;
  }

  checkProximity(x, y);

  if (x===size-1 && y===size-1) {
    alert(`Dotar≈Çe≈õ do celu! Punkty: ${score}`);
    document.getElementById("helipadB").classList.add("visible");
    stopBackgroundDrone();
    gameOver = true;
  }

  drawBoard();
  updateWormMap();
}

function moveWorms() {
  if (!document.getElementById("hardMode").checked) return;
  let newBoard = board.map(row => row.map(cell => ({...cell, worm:false})));
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      if (board[y][x].worm) {
        const dirs = [[0,0],[0,-1],[0,1],[-1,0],[1,0]];
        const [dx,dy] = dirs[Math.floor(Math.random()*dirs.length)];
        let nx = x+dx, ny = y+dy;
        if (nx>=0 && nx<size && ny>=0 && ny<size &&
            !(nx===0 && ny===0) && !(nx===size-1 && ny===size-1)) {
          newBoard[ny][nx].worm = true;
        } else {
          newBoard[y][x].worm = true;
        }
      }
    }
  }
  for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
          board[y][x].worm = newBoard[y][x].worm;
      }
  }
}

function drawBoard() {
  const boardDiv = document.getElementById("board");
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      const cell = boardDiv.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
      cell.className = "cell"; 
      cell.textContent = "";

      if(board[y][x].visited) cell.classList.add("visited");
      if(x===0 && y===0){ cell.classList.add("start"); cell.textContent="A"; }
      if(x===size-1 && y===size-1){ cell.classList.add("goal"); cell.textContent="B"; }
      
      if(x===playerPos.x && y===playerPos.y) {
        cell.textContent = "üë£";
        cell.classList.add("player");
      }
    }
  }
}

function updateWormMap() {
  const wormDiv = document.getElementById("worm-map");
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const cell = wormDiv.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
      cell.classList.remove("player");
      if (x === playerPos.x && y === playerPos.y) {
          cell.textContent = "üë£";
          cell.classList.add("player");
      } else {
          cell.textContent = board[y][x].worm ? "ü™±" : "";
      }
    }
  }
}

function checkProximity(px, py) {
  let minDistance = 999;
  for(let y=0; y<size; y++) {
    for(let x=0; x<size; x++) {
      if(board[y][x].worm) {
        const dist = Math.abs(px - x) + Math.abs(py - y);
        if(dist < minDistance) minDistance = dist;
      }
    }
  }
  updateDroneSound(minDistance);
  if (minDistance === 0) document.body.className = "shake-dist-0";
  else document.body.className = "";
}

function handleDeath() {
  document.body.className = "shake-dist-0";
  // Ods≈Çaniamy czerwie
  const boardDiv = document.getElementById("board");
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      if(board[y][x].worm){
        const cell = boardDiv.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
        cell.classList.add("worm");
        cell.textContent="ü™±";
      }
    }
  }
  updateWormMap();
  stopBackgroundDrone(); 
  setTimeout(() => alert("Po≈ºar≈Ç Ciƒô Czerw Pustyni!"), 100);
  gameOver = true;
}
</script>
</body>
</html>
